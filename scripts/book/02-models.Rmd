---
output: html_document
editor_options: 
  chunk_output_type: console
---
# Models {#runmodels}

In this section, we will: 

1. Combine the data across samples and create new data frames for each personality trait / well-being x covariate x outcome x moderator combination. 
2. As preregistered, we will then rescale variables in each sample to harmonize across samples
3. Next, we will create a series of functions to: 
  + Run the model
  + Extract sample-specific estimates from each sample
  + Extract cross-sample heterogeneity estimates
  + Extract fixed and and random simple slopes
4. Run the models or export files to the computing cluster to speed up runtime.  

## Part 1: Combine Data  

First, we'll just load in all the combined data frames for each sample and keep our core variables:  

```{r load combined data}
loadRData <- function(fileName, type){
#loads an RData file, and returns it
    path <- sprintf("%s/data/clean/%s_cleaned.RData", local_path, fileName)
    load(path)
    get(ls()[grepl(type, ls())])
}

# which(apply(nested_data %>% mutate(cols = map(data, colnames)) %>% select(-data) %>% unnest(cols) %>% mutate(inc = "yes") %>% spread(study, inc), 1, function(x){sum(is.na(x))/7*100}) < 25)

nested_data <- tibble(
  study = studies
  , data = map(str_to_lower(study), ~loadRData(., "combined"))
) %>%
  mutate(
    data = map(data, ~(.) %>% 
                 ungroup() %>% 
                 mutate(SID = as.character(SID)) %>%
                 select(SID, Trait, p_year, p_value, Outcome, o_year, o_value # core variables
                        , one_of(c("age", "gender", "education", "cognition"
                                 , "alcohol", "smokes", "BMI", "race", "SRhealth"
                                 , "stroke", "cancer", "diabetes", "heartProb", "dementia")))
               )
    , study = mapvalues(study, studies, studies_long)
    ) %>%
  unnest(data) %>% 
  # removing this outcome because there was no variance for WUSM MAP
  filter(!(Outcome == "vsclrInfrcts" & study == "ADRC"))

nested_data
```

## Part 2: Clean and Prepare Data Sets  

Next time to rescale or relevel variables.  

### Descriptives 
But first, we'll make a table of descriptive values (M (SD) or percentage) for all variables for each sample.  

```{r tab 2}
cln <- c("Study", "E", "A", "C", "N", "O", "Crystallized / Knowledge", "Age (Years)", "Education (Years)", "% Women")
fctr_vars <- c("dementia", "hipSclerosis", "lewyBodyDis", "tdp43", "vsclrInfrcts", "vsclrMcrInfrcts", "gender"
               , "smokes", "alcohol", "race", "stroke", "cancer", "diabetes", "heartProb")

transpose_df <- function(df) {
  t_df <- data.table::transpose(df)
  colnames(t_df) <- rownames(df)
  rownames(t_df) <- colnames(df)
  t_df <- t_df %>%
    tibble::rownames_to_column(.data = .) %>%
    tibble::as_tibble(.) %>%
    filter(row_number() != 1) %>% 
    set_names(c("Variable", df$study))
  return(t_df)
}

desc_tab <-
  nested_data %>%
  select(-p_year, -o_year, -one_of(fctr_vars)) %>%
  group_by(study, Trait, Outcome) %>%
  mutate_at(vars(p_value, SRhealth), 
            ~((. - min(., na.rm = T))/(max(., na.rm = T) - min(., na.rm = T))*10)) %>%
  mutate_at(vars(p_value, SRhealth),  ~ifelse(is.infinite(.), NA, .)) %>%
  ungroup() %>%
  pivot_wider(names_from = Outcome, values_from = o_value, values_fn = mean) %>%
  pivot_wider(names_from = Trait, values_from = p_value, values_fn = mean)

int_followup <- nested_data %>% 
  select(study, SID, Trait, Outcome, p_year, o_year) %>%
  mutate(interval = o_year - p_year
         , cat = ifelse(Outcome == "dementia", "dem_int", "neuro_int")) %>%
  group_by(study, SID, Trait, cat) %>%
  summarize(interval = mean(interval)) %>%
  group_by(study, SID, cat) %>%
  summarize(interval = mean(interval)) %>%
  group_by(study, cat) %>%
  summarize(int = sprintf("%.2f (%.2f)", mean(interval, na.rm = T), sd(interval, na.rm = T))) %>%
  ungroup() %>%
  pivot_wider(names_from = "cat", values_from = "int")
  
desc_tab <- desc_tab %>%
  group_by(study) %>% 
  mutate(n = n()) %>%
  ungroup() %>%
  left_join(
    desc_tab %>% 
    select(-dementia) %>% 
    filter(!is.na(braak) | !is.na(cerad) | !is.na(tdp43)) %>%
    group_by(study) %>% 
    summarize(n_neuro = n()) %>%
    ungroup() 
  ) %>%
  select(-one_of(fctr_vars)) %>%
  distinct() %>%
  pivot_longer(cols = c(-study, -SID, -n, -n_neuro), values_to = "value", names_to = "item", values_drop_na = T) %>%
  group_by(study, item, n, n_neuro) %>%
  summarize(est = sprintf("%.2f (%.2f)", mean(value, na.rm = T), sd(value, na.rm = T))) %>%
  ungroup() %>%
  pivot_wider(names_from = item, values_from = est) %>%
  full_join(
    nested_data %>% 
      group_by(Outcome, SID, study) %>%
      filter(o_year == min(o_year)) %>%
      ungroup() %>%
      select(-o_year, -dementia) %>%
      pivot_wider(names_from = Outcome, values_from = o_value, values_fn = mean) %>%
      select(-Trait, -p_year, -p_value) %>% 
      distinct() %>%
      select(study, SID, one_of(fctr_vars)) %>% 
      distinct()  %>% 
      group_by(study) %>% 
      summarize_at(vars(-SID), ~ifelse(is.nan(mean(., na.rm = T)), "", sprintf("%i (%.2f%%)", sum(., na.rm = T), mean(., na.rm = T)*100))) %>%
      # summarize_at(vars(-SID), ~mean(., na.rm = T)*100) %>% 
      # mutate_at(vars(-study), ~ifelse(is.nan(.) | is.na(.), "", sprintf("%.2f%%", .))) %>%
      ungroup()
    ) %>%
    full_join(int_followup) %>%
    select(study, E, A, C, N, O, PA, `NA`, SWL, n, dementia, dem_int,
           n_neuro, neuro_int, one_of(outcomes$short_name), 
           age, gender, education, cognition, BMI, SRhealth, smokes, alcohol, 
           BMI, race, stroke, cancer, diabetes, heartProb) %>% 
    transpose_df() %>%
  mutate(Variable = mapvalues(Variable, c("n", "n_neuro", "dem_int", "neuro_int"), c("Valid Dementia N", "Valid Neuropathology N", "Mean Dementia Follow-up (Years)",  "Mean Neuropathology Follow-up (Years)"))
         , Variable = mapvalues(Variable, c(traits$short_name, outcomes$short_name), str_wrap(c(traits$long_name, outcomes$long_name), 25))) %>%
  select(Variable, `Rush-MAP`, ROS, `WUSM-MAP`, EAS, GSOEP, HRS, LISS, SATSA) %>%
  kable(., "html"
        , digits = 2
        # , col.names = cln
        , caption = "<strong>Table 1</strong><br><em>Descriptive Statistics of All Harmonized Measures Across Samples"
        , align = c("l", rep("c",9))) %>%
    kable_classic(full_width = F, html_font = "Times New Roman") %>%
    kableExtra::group_rows("Big Five Personality", 1, 5) %>%
    kableExtra::group_rows("Subjective Well-Being", 6, 8) %>%
    kableExtra::group_rows("Dementia", 9, 11) %>%
    kableExtra::group_rows("Dementia and Neuropathology", 12, 23) %>%
    kableExtra::group_rows("Covariates", 24, 36) %>%
  add_footnote(notation = "none", label = "<em>Note.</em> E = Extraversion; A = Agreeableness; C = Conscientiousness; N = Neuroticism; O = Openness, PA = Positive Affect, NA = Negative Affect, SWL = Satisfaction with Life; Age, education, gender, smoking, alcohol, BMI, chronic conditions, and cognition were assessed at the first baseline personality assessment.", escape = F); desc_tab
save_kable(desc_tab, file = sprintf("%s/results/tables/tab-1-desc.html", local_path))
```

### Zero-Order Correlations  

```{r zero order cor}
r_fun <- function(d){
  d <- d[,apply(d, 2, function(x) sum(!is.na(x)) > 0)]
  cor(d, use = "pairwise")
}

nested_r <- nested_data %>% select(study, SID, Trait, p_value) %>%
  pivot_wider(names_from = "Trait", values_from = "p_value", values_fn = mean) %>%
  left_join(
    nested_data %>% select(study, SID, Outcome, o_value) %>%
      pivot_wider(names_from = "Outcome", values_from = "o_value", values_fn = mean) 
  ) %>%
  left_join(
    nested_data %>% select(study, SID, age:SRhealth, -dementia) %>%
      distinct()
  ) %>% 
  select(-SID) %>%
  group_by(study) %>% 
  nest() %>%
  ungroup() %>%
  mutate(r = map(data, r_fun))
```

#### Table  

```{r cor tables}
cor_tab_fun <- function(r, study){
  coln <- colnames(r)
  colnn <- paste0(1:length(coln), ". ", coln)
  r <- apply(r, c(1,2), function(x) sprintf("%.2f", x))
  rownames(r) <- colnn; colnames(r) <- 1:length(coln)
  r[upper.tri(r)] <- NA
  diag(r) <- "--"
  tab <- r %>% data.frame() %>%
    rownames_to_column("V") %>%
    mutate(V = sprintf("<strong>%s</strong>", V)) %>%
    kable(.
          , "html"
          , col.names = c(" ", sprintf("<strong>%i<s/trong>", 1:length(coln)))
          , align = c("l", rep("c", length(coln)))
          , cap = sprintf("<strong>Table SX</strong><br><em>Zero-Order Correlations Among Variables for %s</em>", study)
          , escape = F
          ) %>%
    kable_classic(full_width = F, html_font = "Times")
  save_kable(tab, file = sprintf("%s/results/tables/zero-order-cor/%s.html", local_path, study))
  return(tab)
}

nested_r <- nested_r %>%
  mutate(tab = map2(r, study, cor_tab_fun))

nested_r$tab[[1]]
```


#### Heat Map  

```{r heat map, fig.width=9, fig.height=10}
r_reshape_fun <- function(r){
  coln <- colnames(r)
  # remove lower tri and diagonal
  r[lower.tri(r, diag = T)] <- NA
  r %>% data.frame() %>%
    rownames_to_column("V1") %>%
    pivot_longer(
      cols = -V1
      , values_to = "r"
      , names_to = "V2"
    ) %>%
    mutate_at(vars(V1, V2), ~factor(., coln))
}

r_plot_fun <- function(r, study){
  p <- r %>% 
    ggplot(aes(x = V1, y = V2, fill = r)) + 
    geom_raster() + 
  geom_text(aes(label = round(r, 2))) + 
  scale_fill_gradient2(limits = c(-1,1)
    , breaks = c(-1, -.5, 0, .5, 1)
    , low = "blue", high = "red"
    , mid = "white", na.value = "white") + 
  labs(
    x = NULL
    , y = NULL
    , fill = "Zero-Order Correlation"
    , title = "Zero-Order Correlations Among Variables"
    , subtitle = study
    ) + 
  theme_classic() + 
  theme(
    legend.position = "bottom"
    , axis.text = element_text(face = "bold")
    , axis.text.x = element_text(angle = 45, hjust = 1)
    , plot.title = element_text(face = "bold", hjust = .5)
    , plot.subtitle = element_text(face = "italic", hjust = .5)
    , panel.background = element_rect(color = "black", size = 1)
  )
  ggsave(p, file = sprintf("%s/results/figures/zero-order-cor/%s.png", local_path, study), width = 14, height = 15)
  ggsave(p, file = sprintf("%s/results/figures/zero-order-cor/%s.pdf", local_path, study), width = 14, height = 15)
  return(p)
}

nested_r <- nested_r %>% 
  mutate(r_long = map(r, r_reshape_fun)
         , p = map2(r_long, study, r_plot_fun))

nested_r$p[[1]]
```


### POMP and Factor Levels  
The first thing we'll do is get everything on the same scale. To do so, and as we preregistered, we will convert:
- age to centered at 60  
- education (in years) to centered at 12 years  
- personality characteristics and cognition to POMP  
- chronic conditions to 0 = no, 1 = yes
- Dementia diagnosis to 0 = no, 1 = yes
- Lewy Body Disease  (binary; 0 = none, 1 = yes, collapsing across types)  
- Gross Cerebral Infarcts, Gross Cerebral Microinfarcts, Hippocampal Sclerosis (binary; 0 = No, 1 = Yes)  

All other indicators have scales that are already standardized across studies (e.g., BMI, Braak stage, CERAD) and will not be transformed.  

Now let's: 

1. POMP personality / well-being and self-rated health
2. Create a chronic conditions composite (sum of stroke, cancer, diabetes, heart problem)
3. Turn binary indicators into factors
4. Center age at 60 years and education at 12 years.

```{r rescale cov and predictors}
nested_data <- nested_data %>%
  group_by(Trait, Outcome, study, p_year) %>%
  mutate_at(vars(p_value, SRhealth),  ~((. - min(., na.rm = T))/(max(., na.rm = T) - min(., na.rm = T))*10)) %>%
  mutate_at(vars(p_value, SRhealth),  ~ifelse(is.infinite(.), NA, .)) %>%
  ungroup() %>%
  mutate(CC = rowSums(cbind(stroke, cancer, diabetes, heartProb), na.rm = T)) %>%
  mutate_at(vars(alcohol, smokes, stroke, cancer, diabetes, heartProb, gender, dementia), factor) %>%
  mutate(age = age - 60
         , education = education - 12
         , interval = o_year - p_year) 
nested_data
```



### Rescale Outcomes  

Now that we've got personality and covariates scaled, we will group by personality characteristic and outcome to rescale outcomes, as needed.  

```{r rescale outcomes}
save_fun <- function(d, trait, outcome){
  if(outcome %in% c("dementia", "hipSclerosis", "lewyBodyDis", "tdp43", "vsclrInfrcts", "vsclrMcrInfrcts")){
    d <- d %>% mutate(o_value = factor(o_value))
  } 
  save(d, file = sprintf("%s/data/SCA/%s-%s.RData", local_path, trait, outcome))
  return(d)
}

nested_data <- nested_data %>%
  group_by(Trait, Outcome) %>%
  nest() %>%
  ungroup() %>%
  mutate(data = pmap(list(data, Trait, Outcome), save_fun))
nested_data 
```

### Bring in Moderators and Covariate Adjustments  

These full data sets will be used for sensitivity analyses and adjusted models, but we also want to set up our data for unadjusted models and moderator tests. For robusteness, we are using a few different sets of theoretically plausible covariates. The goal is to ensure that the pattern of results is not greatly impacted by the inclusion of different covariates. Not knowing the answer to this can be a threat to good science.  

```{r mod data, eval = F}
mod_setup_fun <- function(d, trait, outcome){
  crossing(Covariates = c("fully", "shared", "standard", "butOne", "unadjusted", "shareddx", "standarddx", "sharedint", "int")
           , Moderator = c("none", "education", "age", "gender", "cognition", "dementia")) %>%
    mutate(data = list(d)) %>%
    # filter(Covariates == "sharedint") %>%
    mutate(data = pmap(list(data, trait, outcome, Moderator, Covariates), mod_save_fun))
  return(NULL)
}

mod_save_fun <- function(d, trait, outcome, mod, cov){
  covs <- if(cov == "unadjusted"){
    mod
  } else if (cov %in% c("shared", "shareddx", "sharedint")){
    c(mod, "age", "gender", "education", "smokes", "alcohol")
  } else if (cov %in% c("standard", "standarddx")){
    c(mod, "age", "gender", "education")
  } else if(cov == "butOne"){
    c(mod, "age", "gender", "education", "smokes", "alcohol", "cognition", "CC")
  } else{
    colnames(d)
  }
  if(grepl("dx", cov)) covs <- c(covs, "dementia")
  if(grepl("int", cov)) covs <- c(covs, "interval")
  
  d2 <- d %>% select(study, SID, p_year, p_value, o_year, o_value, one_of(covs), one_of(mod)) %>% filter(complete.cases(.))
  
  # d2 <- if(cov == "unadjusted"){
  #   d %>% select(study, SID, p_year, p_value, o_year, o_value, one_of(mod)) %>% filter(complete.cases(.))
  # } else if (cov == "shared"){
  #   d %>% select(study, SID, p_year, p_value, o_year, o_value, one_of(mod), age, gender, education, smokes, alcohol) %>% filter(complete.cases(.))
  # } else if (cov == "standard"){
  #   d %>% select(study, SID, p_year, p_value, o_year, o_value, one_of(mod), age, gender, education) %>% filter(complete.cases(.))
  # } else if (cov == "butOne") {
  #   d %>% select(study, SID, p_year, p_value, o_year, o_value, one_of(mod), age, gender, education, smokes, alcohol, cognition, CC) %>% filter(complete.cases(.))
  # } else {
  #   d %>% filter(complete.cases(.))
  # }
  # if(mod != "none") colnames(d2)[colnames(d2) == mod] <- "modvalue"
  save(d2, file = sprintf("%s/data/mega-analysis/%s/%s-%s-%s.RData"
                          , local_path, cov, trait, outcome, mod))
  return(NULL)
}

nested_data %>%
  # filter(Outcome != "dementia") %>%
  mutate(data = pmap(list(data, Trait, Outcome), mod_setup_fun))
```

Here's one example: 

```{r example data}
load("/Volumes/Emorie/projects/dementia/prediction/data/mega-analysis/shared/A-angiopathy-gender.RData")
d2
```


## Part 3: Models  
For these first models, we'll be testing three sets of covariates. For a full test of how covariates impact our inferences, we'll then follow up in a later step doing a specification curve / multiverse analysis.  

For these first models, we will run a series of Bayesian regressions. For binary outcomes, these will be multilevel logistic regressions, while for the others, these will be "regular" multilevel linear regressions. For each of these, we will also test age, gender, and education, and cognitive functioning as moderators.  

### Functions   
#### Model Function  

```{r model fun}
ipd_mega_mod_fun <- function(trait, outcome, mod, cov){
  print(paste(trait, outcome, mod, cov))
  ## load the data
  load(sprintf("%s/data/mega-analysis/%s/%s-%s-%s.RData", local_path, cov, trait, outcome, mod))
  
  ## compiled Bayesian model to speed up processing and avoid crashing
  if(outcome %in% c("dementia", "hipSclerosis", "lewyBodyDis", "tdp43", "vsclrInfrcts", "vsclrMcrInfrcts")) load(sprintf("%s/results/bayes_sample_mod_binomial.RData", local_path)) else load(sprintf("%s/results/bayes_sample_mod_continuous.RData", local_path))
  
  ## formula 
  cv <- c("age", "gender", "education", "smokes", "alcohol")
  #if (cov == "shared") cv <- cv
  if (cov == "butOne")  cv <- c(cv, "CC", "cognition")
  if (cov == "fully")    cv <- c(cv, "CC", "cognition", "BMI", "race", "SRhealth")
  if (grepl("standard", cov)) cv <- c("age", "gender", "education")
  if(grepl("dx", cov)) cv <- c(cv, "dementia")
  if(grepl("int", cov)) cv <- c(cv, "interval")
  rhs <- "p_value"
  rhs <- if(cov != "unadjusted") c(rhs, cv) else rhs
  if(mod != "none") rhs <- c(rhs, paste("p_value", mod, sep = "*"))
  re <- if(mod == "none") "(p_value | study)" else paste(paste("(p_value", mod, sep = " * "), "| study)")
  rhs <- paste(c(rhs, re), collapse = " + ")
  f <- paste("o_value ~ ", rhs, collapse = "")
  
  ## run the models & save
  m <- update(m
              , formula = f
              , newdata = d2
              , iter = 1000
              , warmup = 500
              , cores = 12
              , threads = threading(3)
              , backend = "cmdstanr"
              , chains = 4
              )
  save(m, file = sprintf("%s/results/models/%s/%s_%s_%s.RData"
                         , local_path, cov, outcome, trait, mod))
  
  ## extract model terms and confidence intervals & save
  fx <- tidy(m, conf.int = T) %>%
    select(term, estimate, conf.low, conf.high)
  rx <- std_eff_fun(m)
  save(fx, rx, file = sprintf("%s/results/summary/%s/%s_%s_%s.RData"
                         , local_path, cov, outcome, trait, mod))
  
  ## extract heterogeneity estimates
  het <- hetero_fun(m)
  save(het, file = sprintf("%s/results/heterogeneity/%s/%s_%s_%s.RData"
                         , local_path, cov, outcome, trait, mod))
  
  if(mod != "none"){
    # load(sprintf("%s/results/models/%s/%s_%s_%s.RData", local_path, cov, outcome, trait, mod))
    pred.fx <- fx_pred_fun(m, mod)
    pred.rx <- rx_pred_fun(m, mod)
    save(pred.fx, pred.rx, file = sprintf("%s/results/predicted/%s/%s_%s_%s.RData"
                          , local_path, cov, outcome, trait, mod))
    # rm(list = c("pred.fx", "pred.rx", "m"))
    # gc()
    # return(T)
  }
  
  ## clean up the local function environment
  rm(list = c("d", "f", "rhs", "m", "fx", "rx", "het"))
  gc()
}
```

#### Study-Specific Effects Function  

As noted previously, once we run the model, we will have to use a second step to get the study-specific estimates for all studies. Unlike with dummy codes, doing so is much more straightforward. We just have to pull study-specific effects using the `coef()` for both Bayesian and Frequentist approaches.  

```{r study effects function}
std_eff_fun <- function(m){
    coef(m, probs = c(0.025, 0.975))[[1]] %>% array_tree(3) %>% 
      tibble(names = names(.), data = .) %>% 
      mutate(data = map(data, ~(.) %>% data.frame %>% 
        rownames_to_column("study"))) %>% 
      unnest(data) %>% 
      select(names, study, estimate = Estimate, conf.low = Q2.5, conf.high = Q97.5)
}
```

#### Heterogeneity Estimates Function   

The Final pieces of information we need to extract from these models are estimates of the heterogeneity of effects across studies.  

```{r heterogeneity function}
hetero_fun <- function(m){
  args <- list(x = m, effects = "ran_pars", conf.int = T)
  do.call(tidy, args) %>%
    select(group, term, estimate, conf.low, conf.high) %>%
    separate(term, c("est", "term"), sep = "__") %>%
    mutate_at(vars(estimate:conf.high), ~ifelse(est == "sd", .^2, .)) %>%
    mutate(est = ifelse(est == "sd", "var", est))
}
```

#### Simple Effects Function  
##### Fixed Effects  
```{r simple effects}
fx_pred_fun <-function(m, moder){
  d <- m$data 
  d <- d %>% select(-o_value, -study)
  cols <- colnames(d)
  mdr <- if(moder == "dementia") "p_value" else moder
  md_cl <- class(d[,mdr])
  if(any(sapply(d, class) == "numeric")){
    msd <- d %>%
      select_if(is.numeric) %>%
      pivot_longer(everything()
                   , names_to = "item"
                   , values_to = "value") %>%
      group_by(item) %>%
      summarize_at(vars(value), lst(mean, sd)) %>%
      ungroup()
  }
  if(any(sapply(d, class) == "factor")){
    fct_lev <- d %>% 
      select_if(is.factor) %>%
      summarize_all(~list(levels(.)))
  }
  d <- d %>% select(-one_of(moder), -p_value)
  
  md_levs <- if(md_cl == "numeric"){
    if(mdr %in% c("age")) {
      c(-10, 0, 10)
      } else if (mdr %in% c("education")) {
      c(-5, 0, 5) 
      } else {
        with(msd, c(mean[item == mdr] - sd[item == mdr], mean[item == mdr], mean[item == mdr] + sd[item == mdr]))
      }
  } else { 
    sort(unique(fct_lev[,moder][[1]]))
  }
  
  md_fac <- if(moder == "age") c("-10 yrs", "60", "+10 yrs") else if (moder == "education") c("-5 yrs", "12 years", "+5 yrs") else if(moder == "gender") c("Male", "Female") else c("-1 SD", "M", "+1 SD")
  
  if(moder != "dementia"){
    mod_frame <- expand.grid(
      p_value = seq(0,10,.1)
      , modvalue = md_levs
      , stringsAsFactors = F
      ) %>% 
      mutate(mod_fac = factor(modvalue, levels = unique(modvalue), labels = md_fac)) %>%
      setNames(c("p_value", moder, "mod_fac")) 
  } else {
    mod_frame <- expand.grid(
      p_value = with(msd, c(mean[item == "p_value"] - 2.5, mean[item == "p_value"], mean[item == "p_value"] + 2.5))
      , dementia = c(0,1)
    ) %>%
      mutate(mod_fac = factor(p_value, levels = unique(p_value), labels = c("-25%", "M", "+25%")))
  }
  
  if(ncol(d) > 0){
    if(any(sapply(d, class) == "numeric")){
      mod_frame <- tibble(mod_frame, d %>% select_if(is.numeric) %>% summarize_all(mean))
    } 
    if(any(sapply(d, class) == "factor")){
      fcts <- colnames(d)[sapply(d, class) == "factor"]
      for(i in 1:length(fcts)){
        fct <- fcts[i]
        mod_frame <- crossing(
          mod_frame
          , levels(d[,fct])
        ) %>% setNames(c(colnames(mod_frame), fct))
      }
    }
  }
  
  if(moder != "dementia") {
  pred.fx <- bind_cols(
      mod_frame, 
      fitted(m
             , newdata = mod_frame
             , re_formula = NA) %>% data.frame
    ) %>%
    select(one_of(colnames(m$data)), mod_fac, pred = Estimate, lower = Q2.5, upper = Q97.5) %>%
    group_by(p_value, mod_fac) %>% 
    summarize_at(vars(pred, lower, upper), mean) %>%
    ungroup()
  } else {
    pred.fx <- epred_draws(m, mod_frame, re_formula = NA)
    pred.fx <- pred.fx %>% 
      ungroup() %>% 
      filter(dementia == 1) %>% 
      select(p_value, mod_fac, .epred_1 = .epred) %>%
      bind_cols(pred.fx %>% 
                  ungroup() %>% 
                  filter(dementia == 0) %>% 
                  select(.epred_0 = .epred)
                ) %>%
      mutate(diff = .epred_1 - .epred_0) %>%
      select(-.epred_1, -.epred_0) %>%
      group_by(p_value, mod_fac) %>%
      median_qi() %>%
      select(p_value, mod_fac, pred = diff, lower = .lower, upper = .upper)
  }
  
  rm(list = c("m", "mod_frame", "d", "md_levs"))
  gc()
  return(pred.fx)
}
```

##### Study-Specific Effects  
```{r}
rx_pred_fun <- function(m, moder){
  d <- m$data
  d <- d %>% select(-o_value)
  cols <- colnames(d)
  mdr <- if(moder == "dementia") "p_value" else moder
  md_cl <- class(d[,mdr])
  if(any(sapply(d, class) == "numeric")){
    msd <- d %>%
      group_by(study) %>%
      select_if(is.numeric) %>%
      pivot_longer(-study
                   , names_to = "item"
                   , values_to = "value") %>%
      group_by(study, item) %>%
      summarize_at(vars(value), lst(mean, sd), na.rm = T) %>%
      ungroup() 
  }
  if(any(sapply(d, class) == "factor")){
    fct_lev <- d %>% 
      group_by(study) %>%
      select_if(is.factor) %>%
      summarize_all(~list((levels(.)))) %>%
      ungroup()
  }
  d <- d %>% select(-one_of(moder), -p_value)
  
  md_fac <- if(moder == "age") c("-10 yrs", "60", "+10 yrs") else if (moder == "education") c("-5 yrs", "12 years", "+5 yrs") else if(moder == "gender") c("Male", "Female") else c("-1 SD", "M", "+1 SD")
  
  md_levs <- if(!moder %in% c("cognition", "dementia")){
    crossing(
      study = unique(d$study)
      , modvalue = if(mdr == "age") c(-10, 0, 10) else if (mdr == "education") c(-5,0,5) else c(0,1)
    ) %>%
      mutate(mod_fac = factor(modvalue, levels = unique(modvalue), labels = md_fac)) %>%
      setNames(c("study", moder, "mod_fac"))
  } else if(moder != "dementia") {
    msd %>% 
      filter(item == moder) %>%
      mutate(lower = mean - sd, upper = mean + sd) %>%
      select(-sd) %>% 
      pivot_longer(cols = c(mean, lower, upper)
                   , names_to = "meas"
                   , values_to = "modvalue") %>%
      pivot_wider(names_from = "item", values_from = "modvalue") %>%
      select(study, one_of(moder)) %>%
      setNames(c("study", "modvalue")) %>%
      group_by(study) %>%
      mutate(mod_fac = factor(modvalue, levels = sort(unique(modvalue)), labels = md_fac)) %>%
      ungroup() %>%
      setNames(c("study", moder, "mod_fac"))
  } else {
    msd %>% 
      filter(item == mdr) %>%
      mutate(lower = mean - 2.5, upper = mean + 2.5) %>%
      select(-sd) %>% 
      pivot_longer(cols = c(mean, lower, upper)
                   , names_to = "meas"
                   , values_to = "modvalue") %>%
      pivot_wider(names_from = "item", values_from = "modvalue") %>%
      select(study, meas, one_of(mdr)) %>%
      setNames(c("study", "meas", "modvalue")) %>%
      group_by(study) %>%
      mutate(mod_fac = factor(meas, levels = c("lower", "mean", "upper"), labels = c("-25%", "M", "+25%"))) %>%
      ungroup() %>%
      select(-meas) %>%
      setNames(c("study", mdr, "mod_fac"))
  }
     
  mod_frame <- if(moder != "dementia"){
    crossing(
      p_value = seq(0,10,.1)
      , md_levs
    )
  } else {
    crossing(
      md_levs
      , dementia = c(0,1)
    )
  }
  
  if(ncol(d) > 0){
    if(any(sapply(d, class) == "numeric")){
      mod_frame <- d %>% 
        group_by(study) %>% 
        select_if(is.numeric) %>% 
        summarize_all(mean, na.rm = T) %>%
        ungroup() %>%
        full_join(mod_frame)
    } 
    if(any(sapply(d, class) == "factor")){
      fcts <- colnames(d)[sapply(d, class) == "factor"]
      for(i in 1:length(fcts)){
        fct <- fcts[i]
        mod_frame <- crossing(
          mod_frame
          , levels(d[,fct])
        ) %>% setNames(c(colnames(mod_frame), fct))
      }
    }
  }
  
  if(moder != "dementia") {
    pred.rx <- bind_cols(
      mod_frame, 
      fitted(m
             , newdata = mod_frame) %>% data.frame
    ) %>%
    select(one_of(colnames(m$data)), mod_fac, pred = Estimate, lower = Q2.5, upper = Q97.5) %>%
    group_by(p_value, mod_fac, study) %>% 
    summarize_at(vars(pred, lower, upper), mean) %>%
    ungroup() 
  } else {
    pred.rx <- epred_draws(m, mod_frame)
    pred.rx <- pred.rx %>% 
      ungroup() %>% 
      filter(dementia == 1) %>% 
      select(study, p_value, mod_fac, .epred_1 = .epred) %>%
      bind_cols(pred.rx %>% 
                  ungroup() %>% 
                  filter(dementia == 0) %>% 
                  select(.epred_0 = .epred)
                ) %>%
      mutate(diff = .epred_1 - .epred_0) %>%
      select(-.epred_1, -.epred_0) %>%
      group_by(study, p_value, mod_fac) %>%
      median_qi() %>%
      select(study, p_value, mod_fac, pred = diff, lower = .lower, upper = .upper)
  }
  
  rm(list = c("m", "mod_frame", "d"))
  gc()
  return(pred.rx)
}
```

### Run Models and Summaries  

#### Sample Bayesian Models  

Before we actually run the models, we will estimate two models on smaller subsets of data. The advantage to this is that it prevents the rstan model from having to recompile the model, which speeds up runtime and prevents random crashes. It's going to fit badly. That's fine. It was given almost no data.  

```{r sample models, eval = F}
# Sample Bayesian Model 
# load data 
load(sprintf("%s/data/mega-analysis/sharedint/N-dementia-none.RData", local_path))
# load("data/mega-analysis/shared/N-dementia-none.RData")

# clean data & keep only needed columns and a subset of the used variables
d <- d2 %>%
  group_by(study) %>%
  nest() %>%
  ungroup() %>%
  mutate(data = map(data, ~(.) %>% filter(row_number() %in% sample(1:nrow(.), 100, replace = F)))) %>%
  unnest(data) 

# set priors & model specifications 
Prior <-  c(set_prior("cauchy(0,1)", class = "sd"),
            set_prior("student_t(3, 0, 2)", class = "b"),
            set_prior("student_t(3, 0, 5)", class = "Intercept"))
Iter <- 30; Warmup <- 21; treedepth <- 20
f <- formula(o_value ~ p_value + age + gender + interval + p_value*education + (p_value*education | study))
m <- brm(formula = f
            , data = d
            , family = bernoulli(link = "logit")
            , prior = Prior
            , iter = Iter
            , warmup = Warmup
            , cores = 12
            , threads = threading(3)
            , backend = "cmdstanr"
            , chains = 4)

save(m, file = sprintf("%s/results/bayes_sample_mod_binomial.RData", local_path))
# save(m, file = "results/bayes_sample_mod_binomial.RData")

load(sprintf("%s/data/mega-analysis/sharedint/N-braak-none.RData", local_path))
# load("data/mega-analysis/shared/N-braak-none.RData")

# clean data & keep only needed columns and a subset of the used variables
d <- d2 %>%
  group_by(study) %>%
  nest() %>%
  ungroup() %>%
  mutate(data = map(data, ~(.) %>% filter(row_number() %in% sample(1:nrow(.), 100, replace = T)))) %>%
  unnest(data) 

# set priors & model specifications 
Prior <-  c(set_prior("cauchy(0,1)", class = "sd"),
            set_prior("student_t(3, 0, 2)", class = "b"),
            set_prior("student_t(3, 0, 5)", class = "Intercept"))
Iter <- 30; Warmup <- 21; treedepth <- 20
f <- formula(o_value ~ p_value + age + gender + interval + p_value*education + (p_value*education | study))
m <- brm(formula = f
            , data = d
            , prior = Prior
            , iter = Iter
            , warmup = Warmup
            , cores = 12
            , threads = threading(3)
            , backend = "cmdstanr"
            , chains = 4)

save(m, file = sprintf("%s/results/bayes_sample_mod_continuous.RData", local_path))
# save(m, file = "results/bayes_sample_mod_continuous.RData")
rm(list = c("d", "Prior", "Iter", "Warmup", "treedepth", "f", "m"))
```

##### Binary 

```{r load binary brms}
load(sprintf("%s/results/bayes_sample_mod_binomial.RData", local_path))
m
```

##### Continuous  

```{r load continuous brms}
load(sprintf("%s/results/bayes_sample_mod_continuous.RData", local_path))
```


#### Run the Models  

```{r ipd reg run models, eval = F}
done <- tibble(Covariate = c("fully", "shared", "butOne", "unadjusted", "standard", "standarddx", "shareddx", "sharedint"),
               file = map(Covariate, ~list.files(sprintf("%s/results/models/%s", local_path, .)))) %>%
  unnest(file) %>%
  separate(file, c("Outcome", "Trait", "Moderator"), sep = "_") %>%
  mutate(Moderator = str_remove_all(Moderator, ".RData")
         , done = "done") %>%
  filter(!is.na(Moderator))

# plan(multisession(workers = 4L))
nested_ipd_mega <- crossing(
  Trait = traits$short_name
  , Outcome = outcomes$short_name
  , Moderator = c("education", "age", "gender", "cognition", "dementia")
  , Covariate = c("fully", "shared", "butOne", "standard", "unadjusted", "standarddx", "shareddx", "sharedint")
) %>%
  full_join(
    crossing(
      Trait = traits$short_name
      , Outcome = outcomes$short_name
      , Moderator = "none"
      , Covariate = c("fully", "shared", "butOne", "standard", "unadjusted", "standarddx", "shareddx", "sharedint") #  "int",
      )
) %>%
  # mutate(run = future_pmap(
  mutate(run = pmap(
    list(Trait, Outcome, Moderator, Covariate)
    , possibly(ipd_mega_mod_fun, NA_real_)
    # , ipd_mega_mod_fun
    # , .options = furrr_options(
    #                    globals = c("traits", "moders", "covars", "outcomes"
    #                                , "hetero_fun"
    #                                , "rx_pred_fun"
    #                                , "std_eff_fun"
    #                                , "fx_pred_fun"
    #                                , "local_path")
    #                    , packages = c("broom", "broom.mixed", "tidyverse", "brms")
    #                    )
    #                  , .progress = T
    ))

# nested_ipd_mega %>% 
#   mutate(Covariate = factor(Covariate)
#          , Covariate = relevel(Covariate, "shared")
#          # , Moderator = factor(Moderator, levels = moders$short_name)
#          , Moderator = relevel(factor(Moderator), "dementia")
#          ) %>%
#   arrange(Covariate, Outcome, Moderator, Trait) %>% 
#   filter(Covariate != "fully") %>% 
#   select(Trait, Outcome, Moderator, Covariate) %>%
#   write.table(.
#               , file = sprintf("%s/scripts/cluster/args/args.txt", local_path)
#               , row.names = F)
```

